[[TableOfContents]]

= Questions =
Should we [http://www.livejournal.com/~codetoad/206453.html store the page text/cached versions] in the DB? -- So far, we're leaning toward a strong 'yes.'

Should we store the images in the database?  Images are much larger than text, so the ability of the DB to query cache is essential here, and apache might likely trump MySQL in caching on this issue.  If we stored the images in a database that would mean a much more streamlined backup process.  The downside is possibly speed issues.  Also, we'd need a little helper script called 'img' or somethign such to pull images out.  If we used files as images then we'd have to do lookup (so we'd hit the DB anyway, but with less throughput).  We'd then have two data organization schemes -- the DB and the image file hierarchy.

== Blobs in python? ==
We're playing with the [http://sourceforge.net/projects/mysql-python MySQLdb] python module.  I don't know the right way to put binary objects into the DB.  This is important because we'd like to store the cached version of a page as binary.  So what I've been doing is something like this:

{{{
            code = compile(src, self.page_name, 'exec')
            cache.update(marshal.dumps(code))
}}}

where marshal.dumps takes a python object and serializes it to a string.

then: 
{{{
        cursor.execute("UPDATE curPages set cachedText=%s, cachedTime=FROM_UNIXTIME(%s) where name=%s", (content, time.time(), self.key))
}}}


This is lame.  I'd just like to be able to store the binary object in the field like I'm supposed to.  I might as well be using a string and not a blob..

== db connection ==
I think it might be faster/better to do the MySQLdb.connect() in the request object, once, and then just keep calling it...?  The DB connection could be a part of the request object?  Is there a downside to this?  (an instance where we need to use the DB but don't have a request object?)

= Schema =
{{{Tables:

create table curPages
  (
  name varchar(255) primary key,
  text mediumtext,
  cachedText mediumblob,
  editTime datetime,
  cachedTime datetime,
  userEdited char(19)
  ) type=InnoDB;

alter table curPages add index userEdited(userEdited);

create table allPages
 (
    name varchar(255),
    text mediumtext,
    editTime datetime,
    userEdited char(19),
    editType enum('SAVE','SAVENEW','ATTNEW','ATTDEL','RENAME','NEWEVENT','COMMENT_MACRO','SAVE/REVERT'),
    comment varchar(81),
    primary key(name, editTime)
  ) type=InnoDB;

alter table allPages add index userEdited(userEdited);

create table users
(
id char(19) primary key,
name varchar(255),
email varchar(255),
enc_password varchar(255),
language varchar(80),
remember_me tinyint,
css_url varchar(255),
disabled tinyint,
edit_cols tinyint,
edit_rows tinyint,
edit_on_doubleclick tinyint,
theme_name char(40),
last_saved datetime,
join_date datetime,
created_count tinyint default 0,
edit_count tinyint default 0,
file_count tinyint default 0,
last_page_edited varchar(255),
last_edit_date datetime,
rc_bookmark datetime,
rc_showcomments tinyint default 1
) type=InnoDB;

alter table users add index name(name);

create table userFavorites
(
  username varchar(255),
  page varchar(255),
  viewTime datetime,
  primary key (username, page)
) type=InnoDB;

#This is throw-away data. User sessions aren't that important so we'll use a MyISAM table for speed
create table userSessions
(
  user_id char(19),
  session_id char(30),
  secret char(30),
  expire_time datetime,
  primary key (user_id, session_id)
) type=MyISAM;

alter table userSessions add index expire_time (expire_time);

#Links can be re-created if corrupt.  No need to worry about integrity so we'll use MyISAM for speed.
create table links
(
  source_pagename varchar(255),
  destination_pagename varchar(255),
  primary key (source_pagename, destination_pagename)
) type=MyISAM;

create table events
(
  uid mediumint primary key,
  event_time datetime,
  posted_by varchar(255) references users(name),
  text mediumtext,
  location mediumtext,
  event_name mediumtext
) type=InnoDB;

alter table events add index event_time (event_time);
}}}

= To do =
== Basic working parts ==
 * --X Reading/writing of pages and backups. X--
 * --X Info, revisions, diffs, etc. X--
 * --X make sure pagedict is no where to be found in the code X--
 * --X ["Recent Changes"] X--
 * --X ["Bookmarks"] X--
 * --X ..then get rid of the logfile stuff -- search for it, kill it,X-- then kill the .py's
 * Misc functions

== The fun stuff ==
 * --X user table X-- and everything involved with removing the file-based user system
    * --X basics X--
    * --Xuser stats done via the user tableX--
    * --Xfavorites tableX--
  * --XCookies done via a table, as well.  Kill the damned seralized bullshit.X--
 * --Xlink tableX--

== harder but also fun stuff ==
 * --Xevents boardX--
 * images
 * population script
[[Comments]]
