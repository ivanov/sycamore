{{{[[Image(filename, caption, size, alignment, thumb, noborder, border)]]}}}


filename -- name of the file, an image.
  '''required''' -- should provide error message if not present.  must be the first element.  all others can be in any order.

size -- the size of the image.  if size is supplied this implies it's a thumbnail. Can be either width or height depending on whichever is larger in source image. The size supplied is the desired scaled size.

alignment -- left/right.  if it's a thumbnail then it gives it a usual float:left or float:right.  if it's not  a thumbnail then you need to wrap the image in a div that sends it left or right (i'm not sure it even needs to float..)

thumb -- this is just the string "thumb" or "thumbnail" that tells us it's a thumbnail. optional if size is supplied, if size not supplied defaults to (default size?). Should default size be a systemwide variable, or hard coded?

noborder -- just the string "noborder" to tell us, for non-thumbnails, to not use the tiny black image border.  in the case it's a thumbnail, i suppose the best behavior would be to drop the caption and frame around the thumbnail (sort of consealing its thumbnail-ness)
  could we still keep caption without border?

border -- just for symmetry's sake.   this does nothing (borders are supplied by default)
----

The second part is a script that converts the various formats into the new format.  This means we supply a string to the script:

{{{
attachment:image.jpg --> [[Image(image.jpg)]]

borderless:image.jpg --> [[Image(image.jpg, noborder)]]

[[Thumbnail(image.jpg)]] --> [[Image(image.jpg, thumbnail)]]

[[Thumbnail(image.jpg, 300, right)]] --> [[Image(image.jpg, thumbnail, 300, right)]]

[[Thumbnail(image.jpg, "hi there!")]] --> [[Image(image.jpg, thumbnail, "hi there!")]]
}}}


long range hooks to consider would be the ability to display a gallery of pictures in an orderly fashion that may not all share the same aspect ratio.
------

Okay, here's my script for converting to the new macro.  Hopefully it should work.  I can also work on the interface some more too.  Note that it probably takes twice as long to run as it should.  But it's perl anyway, so who cares by that point. --["BrentLaabs"]

{{{
#!/usr/bin/perl

# dethumb.pl
# syntax:  perl dethumb.pl [input file] [output file]

use warnings;
$/ = undef;

defined($ARGV[0]) or die "syntax:  perl dethumb.pl [input file] [output file]\n";

$filein = $ARGV[0];
$fileout = $ARGV[1];

open(WIKIPAGE, "<", $filein) or die "Can't open input: $filein\n";

$wiki = <WIKIPAGE>;

close WIKIPAGE;


@comments = undef;
$i = 0;

while ($wiki =~ /\{\{\{.*?\}\}\}/s) {
	if ( $wiki =~ s/(\{\{\{.*?\}\}\})/smurf$i/s) {
		$comments[$i] = $1;
	}
	$i++;
}


while ($wiki =~ /attachment:/s  ) {
	$wiki =~ s/attachment:(\w+?\.\w\w\w\w?)(\W)/[[Image($1)]]$2/s;
}

while ($wiki =~ /borderless:/s  ) {
	$wiki =~ s/borderless:(\w+?\.\w\w\w\w?)(\W)/[[Image($1, noborder)]]$2/s;
}




# thumbnails!
while($wiki =~ /\[\[Thumbnail/    ) {
	if ($wiki =~ s/\[\[Thumbnail\((.+?)\)\]\]/smurfsmurf/ ) {
		$thumbargs = $1;
	}
	$caption = undef;
	# get caption, if exists
	if ($thumbargs =~ /".*"/) {
		if ($thumbargs =~ s/,\s*"(.*)"//) {
			$caption = $1;
		}
	}
	#clear whitespace
	$thumbargs =~ s/\s//g;
	@thumbarg = undef;
	# get remaining arguments
	@thumbarg = split /,/, $thumbargs;
	$imagefile = $thumbarg[0];
	$imagesize = $leftitude = undef;
	for($k=1; $k <= $#thumbarg; $k++) {
		$thumbarg[$k] =~ /\d/ and $imagesize = $thumbarg[$k];
		$thumbarg[$k] =~ /left/ and $leftitude = $thumbarg[$k];
		$thumbarg[$k] =~ /right/ and $leftitude = $thumbarg[$k];
	}
	$imagestring = '[[Image(' . $imagefile;
	defined($caption) and   $imagestring = $imagestring . ', "' . $caption . '"';
	defined($imagesize) and $imagestring = $imagestring . ', ' . $imagesize;
	defined($leftitude) and  $imagestring = $imagestring . ', ' . $leftitude;
	
	$imagestring = $imagestring . ', ' . 'thumbnail)]]';
 #	print $imagestring; 
	# insert new image tag
	$wiki =~ s/smurfsmurf/$imagestring/;
}


while ($wiki =~ /smurf\d/) {
	$wiki =~ s/smurf(\d+)/$comments[$1]/s;
}



open(WIKIOUT, ">", $fileout) or die "Can't open output: $fileout\n";
print WIKIOUT $wiki;
close WIKIOUT;

print "exit success\n";


}}}

''The script doesn't seem to work right.  I tried running it on the raw markup of the front page and it didn't convert the markup properly.  It works on the user page PhilipNeustrom, but it smashes together all the quoted text.''
 * This should address the the fact that I removed the whitespace too soon, as well as the fact that any non-alphanumeric character terminates the attachment.  I really need to know what characters are allowed in filenames, and how the parser determines what image filenames are valid, to be sure that I'm not losing info from the {{{attachment:}}} and {{{borderless:}}}. statements.
  * {{{attachment:asdkjasdaskjhasd}}} can never have spaces in it.  So the file name is the entire string up until the first space.
